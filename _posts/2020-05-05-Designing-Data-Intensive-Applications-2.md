---
layout:     post
title:      "数据密集型应用设计（二）"
subtitle:   "读书手记"
date:       2020-05-05 23:10:00
author:     "Tyr"
header-img: "img/white-graphing-paper-164686.jpg"
tags:
    - 读书笔记
    - 软件架构
    - 数据密集型应用设计
---

## 数据模型与查询语言

### 数据模型

采用哪种类型的数据模型是数据描述和存储的关键，也会影响着软件开发的方式。

关系模型是称霸了近30年，成熟并广泛运用的数据模型。就是我们熟知的SQL。

对于关系模型最大的问题在于模型的扩展性，即对异构数据和数据灵活性的支持不够。另一个问题则是开发过程中的“对象关系不匹配”问题，即需要通过ORM做关系到对象的映射。

文档模型（NoSQL）通过完整文档记录数据，通过局部性可以拥有更简单查询，更高的效率，更灵活的模型结构。

但文档模型也并非完美，关于多个对象间的信息关联和冗余存储及其同步，是文档模型不得不面对的问题，这其实是一个副本问题：

> 存储ID还是文本字符串，这是个 副本（duplication） 问题。当使用ID时，对人类有意义的信息（比如单词：Philanthropy）只存储在一处，所有引用它的地方使用ID（ID只在数据库中有意义）。当直接存储文本时，对人类有意义的信息会复制在每处使用记录中。

而关系模型明显具有更好的，多对一和多对多支持。

文中对于NoSQL“无模式”的说法，进行了一个很有意思的拆解：

> 文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）

这其实很容易理解，就是关系模型的数据结构定义是有约束的，不符合要求的数据无法被写入，因此读取数据时不需要留心这种不匹配，而文档模型必须在读取到展示前，做模式检查，即并不保证读出的数据格式是否满足约束要求。

这有点像编程语言中静态类型检查还是动态类型检查的差异。这其实也就是引起灵活性争论的本质，当模型变更时，是修改数据模型的模式（ALTER TABLE），还是修改数据读取后的校验逻辑（IF）的问题。

文档模型的大小是设计时需要考虑的问题：

> 数据库通常需要加载整个文档，即使只访问其中的一小部分，这对于大型文档来说是很浪费的。更新文档时，通常需要整个重写。只有不改变文档大小的修改才可以容易地原地执行。因此，通常建议保持相对小的文档，并避免增加文档大小的写入。这些性能限制大大减少了文档数据库的实用场景。

现代数据库已经开始支持关系模型和文档模型的结合，比如postgre的JSONB列。

文中还介绍了图数据库，即假设对象均有关联，这也是一种NoSQL模型，与文档模型是两个极端：

> 1.文档数据库的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。
>
> 2.图形数据库用于相反的场景：任意事物都可能与任何事物相关联。

### 数据查询语言

查询语言主要分为命令式和声明式：

> 命令式语言告诉计算机以特定顺序执行某些操作。可以想象一下，逐行地遍历代码，评估条件，更新变量，并决定是否再循环一遍。
>
> 在声明式查询语言（如SQL或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些条件，以及如何将数据转换（例如，排序，分组和集合） - 但不是如何实现这一目标。数据库系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。

以web举例来说，就是通过css去修饰样式（声明式）还是js语句修饰样式（命令式）的区别。可以看出声明式更具魅力。

还有一种是介于两者之间的，或者说是两者结合的，比如MapReduce。