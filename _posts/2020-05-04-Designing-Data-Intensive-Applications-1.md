---
layout:     post
title:      "数据密集型应用设计（一）"
subtitle:   "读书手记"
date:       2020-05-04 23:10:00
author:     "Tyr"
header-img: "img/bandwidth-close-up-computer-connection-1148820.jpg"
tags:
    - 读书笔记
    - 软件架构
    - 数据密集型应用设计
---

> 打开编辑器，也是把自己吓了一跳，上一次写文字已经要追溯到4月，假期琐碎事情让自己也懒惰了。还好最近在看这本书《Designing Data-Intensive Applications》,凑个读书手记系列吧。

## 引子

目前阅读了前面两章内容，总体来看相见恨晚，这本书对于现在的我来说，读起来还是非常舒适和实用的。首先内容上非常贴合实例，仿佛洞察了目前系统中全部的问题和可能的解决方案，并对方案进行深入的解读和剖析。

## 第一章 可靠性、可扩展性、可维护性

本书开篇就阐明一个观点：

> 现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（computeintensive） 的。因此CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。

这个观点也是非常吸引我阅读本书的一个原因，因为这与我之前提到的关于数据膨胀带来的挑战是不谋而合的，即现代系统无非考虑两个问题：如何处理或处置海量数据流，如何利用数据。

本书主要讨论的正是第一个问题。而开篇第一章的内容，主要从系统实现目标的三个方面进行描述：可靠性、可扩展性、可维护性。

### 可靠性

从硬件、软件、人为三个方面介绍了可能引起系统不可靠的问题，也简单提及了一些解决方案，因为只是第一章，做了个简单的启示作用。

比如简单提及的故障转移和硬件冗余，软件进程隔离，进程自检预警，最小化人为干预，快速回滚和恢复机制。

正如所料，人为错误导致的不可靠首当其冲，硬件故障相对是影响最小的（有应对方案的前提下。

### 可扩展性

主要是对如何描述负载进行了约定，即系统对特定工作的作业时间或请求响应时间。

由于不同条件下，相同请求的响应时间可能不同。所以这个描述是一个数据分布，而不是特定值。所以从性能描述或性能测试角度，一般会采用百分比去描述性能，而不是平均数，比如中位数，表示p50，一半请求低于这个值，而一半请求高于这个值。

这时p99等值会比较有用，即极端情况下，到底能有多慢。主要用于描述服务可用性和性能级别。

业务增长带来的性能问题，需要通过重新考虑架构来解决，因为没有一种万能的架构方案。

扩展主要是纵向扩展（增加单机性能）和横向扩展（增加机器数量），无状态应用使用横向扩展会非常便利，带有数据状态的服务则非常使用纵向扩展，而横向扩展会有很多挑战。这个有实际经验的都会很有感悟。具体模式应该后续章节会介绍。

### 可维护性

简单做个摘录：

    运维团队对于保持软件系统顺利运行至关重要。一个优秀运维团队的典型职责如下（或者更多）：
    
    监控系统的运行状况，并在服务状态不佳时快速恢复服务
    跟踪问题的原因，例如系统故障或性能下降
    及时更新软件和平台，比如安全补丁
    了解系统间的相互作用，以便在异常变更造成损失前进行规避。
    预测未来的问题，并在问题出现之前加以解决（例如，容量规划）
    建立部署，配置、管理方面的良好实践，编写相应工具
    执行复杂的维护任务，例如将应用程序从一个平台迁移到另一个平台
    当配置变更时，维持系统的安全性
    定义工作流程，使运维操作可预测，并保持生产环境稳定。
    铁打的营盘流水的兵，维持组织对系统的了解。

    数据系统可以通过各种方式使日常任务更轻松：
    通过良好的监控，提供对系统内部状态和运行时行为的可见性（visibility）
    为自动化提供良好支持，将系统与标准化工具相集成
    避免依赖单台机器（在整个系统继续不间断运行的情况下允许机器停机维护）
    提供良好的文档和易于理解的操作模型（“如果做X，会发生Y”）
    提供良好的默认行为，但需要时也允许管理员自由覆盖默认值
    有条件时进行自我修复，但需要时也允许管理员手动控制系统状态
    行为可预测，最大限度减少意外

另外就是描述了使用抽象去减少复杂度，通过敏捷等拥抱变化。

第一章完，太晚了，第二章留个稿，明天写。